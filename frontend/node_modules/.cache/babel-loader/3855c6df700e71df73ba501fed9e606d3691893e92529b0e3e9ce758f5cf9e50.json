{"ast":null,"code":"// FRD = Firebase Realtime Database\nimport { ref, push, update, onValue } from \"firebase/database\";\nimport { db } from \"./firebase\"; // Firebase初期化ファイルからデータベースをインポート\nimport { auth } from \"./firebase\"; // Firebaseの認証情報をインポート\n\n// プレイヤーネームの保存\nexport const savePlayerName = async playerName => {\n  const user = auth.currentUser; // 現在のユーザーを取得\n  if (user) {\n    const userId = user.uid;\n    await update(ref(db, 'users/' + userId), {\n      name: playerName\n    });\n    return userId;\n  } else {\n    throw new Error(\"ユーザーがログインしていません\");\n  }\n};\n\n// マッチングリクエスト\nexport const requestMatch = async () => {\n  const user = auth.currentUser; // 現在のユーザーを取得\n  if (user) {\n    const userId = user.uid;\n    const matchRef = push(ref(db, 'matches'));\n    await update(matchRef, {\n      player1: userId,\n      status: 'waiting'\n    });\n    return matchRef.key;\n  } else {\n    throw new Error(\"ユーザーがログインしていません\");\n  }\n};\n\n// マッチング成功時のリスナー\nexport const onMatchFound = callback => {\n  const matchRef = ref(db, 'matches');\n  onValue(matchRef, snapshot => {\n    const matches = snapshot.val();\n    if (matches) {\n      Object.keys(matches).forEach(key => {\n        const match = matches[key];\n        if (match.status === 'waiting') {\n          // マッチング成立の処理を行う\n          callback({\n            roomId: key,\n            opponentId: match.player1,\n            battleConfig: match.battleConfig // 必要なデータを追加\n          });\n        }\n      });\n    }\n  });\n};\n\n// メッセージの送信\nexport const sendMessage = async (roomId, message) => {\n  const user = auth.currentUser; // 現在のユーザーを取得\n  if (user) {\n    const messageRef = ref(db, 'rooms/' + roomId + '/messages');\n    await push(messageRef, {\n      senderId: user.uid,\n      message\n    });\n  } else {\n    throw new Error(\"ユーザーがログインしていません\");\n  }\n};\n\n// ターン更新リスナー\nexport const onTurnUpdated = (roomId, callback) => {\n  const logRef = ref(db, 'rooms/' + roomId + '/battleLog');\n  onValue(logRef, snapshot => {\n    const battleLog = snapshot.val();\n    if (battleLog) {\n      callback(battleLog);\n    }\n  });\n};\n\n// バトル終了リスナー\nexport const onBattleEnd = (roomId, callback) => {\n  const roomRef = ref(db, 'rooms/' + roomId + '/status');\n  onValue(roomRef, snapshot => {\n    const status = snapshot.val();\n    if (status === 'ended') {\n      callback();\n    }\n  });\n};","map":{"version":3,"names":["ref","push","update","onValue","db","auth","savePlayerName","playerName","user","currentUser","userId","uid","name","Error","requestMatch","matchRef","player1","status","key","onMatchFound","callback","snapshot","matches","val","Object","keys","forEach","match","roomId","opponentId","battleConfig","sendMessage","message","messageRef","senderId","onTurnUpdated","logRef","battleLog","onBattleEnd","roomRef"],"sources":["/Users/ryotarooda/Desktop/卒論/TuringChats/turing-chat-d/turing-chat-d11/frontend/src/services/FRD.ts"],"sourcesContent":["// FRD = Firebase Realtime Database\nimport { getDatabase, ref, push, update, onValue } from \"firebase/database\";\nimport { db } from \"./firebase\"; // Firebase初期化ファイルからデータベースをインポート\nimport { auth } from \"./firebase\"; // Firebaseの認証情報をインポート\n\n// プレイヤーネームの保存\nexport const savePlayerName = async (playerName: string) => {\n  const user = auth.currentUser; // 現在のユーザーを取得\n  if (user) {\n    const userId = user.uid;\n    await update(ref(db, 'users/' + userId), { name: playerName });\n    return userId;\n  } else {\n    throw new Error(\"ユーザーがログインしていません\");\n  }\n};\n\n// マッチングリクエスト\nexport const requestMatch = async () => {\n  const user = auth.currentUser; // 現在のユーザーを取得\n  if (user) {\n    const userId = user.uid;\n    const matchRef = push(ref(db, 'matches'));\n    await update(matchRef, { player1: userId, status: 'waiting' });\n    return matchRef.key;\n  } else {\n    throw new Error(\"ユーザーがログインしていません\");\n  }\n};\n\n// マッチング成功時のリスナー\nexport const onMatchFound = (callback: (data: any) => void) => {\n  const matchRef = ref(db, 'matches');\n  onValue(matchRef, (snapshot) => {\n    const matches = snapshot.val();\n    if (matches) {\n      Object.keys(matches).forEach((key) => {\n        const match = matches[key];\n        if (match.status === 'waiting') {\n          // マッチング成立の処理を行う\n          callback({\n            roomId: key,\n            opponentId: match.player1,\n            battleConfig: match.battleConfig, // 必要なデータを追加\n          });\n        }\n      });\n    }\n  });\n};\n\n// メッセージの送信\nexport const sendMessage = async (roomId: string, message: string) => {\n  const user = auth.currentUser; // 現在のユーザーを取得\n  if (user) {\n    const messageRef = ref(db, 'rooms/' + roomId + '/messages');\n    await push(messageRef, { senderId: user.uid, message });\n  } else {\n    throw new Error(\"ユーザーがログインしていません\");\n  }\n};\n\n// ターン更新リスナー\nexport const onTurnUpdated = (roomId: string, callback: (data: any) => void) => {\n  const logRef = ref(db, 'rooms/' + roomId + '/battleLog');\n  onValue(logRef, (snapshot) => {\n    const battleLog = snapshot.val();\n    if (battleLog) {\n      callback(battleLog);\n    }\n  });\n};\n\n// バトル終了リスナー\nexport const onBattleEnd = (roomId: string, callback: () => void) => {\n  const roomRef = ref(db, 'rooms/' + roomId + '/status');\n  onValue(roomRef, (snapshot) => {\n    const status = snapshot.val();\n    if (status === 'ended') {\n      callback();\n    }\n  });\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}